from langchain_core.messages import trim_messages
from langchain_core.runnables import RunnablePassthrough
from langchain.schema import AIMessage, HumanMessage
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder

from operator import itemgetter
import datetime

from translator import Translator

class Chatbot:
    def __init__(self, model):
        self.model = model
        # List to save the conversation messages
        self.messages = []
        # Set up session ID and configuration
        # self.session_id = input('Name the session: ')
        self.config = {"configurable": {"session_id": {'abc123'}}}

        # Configures a trimmer to manage long messages in the context by retaining recent messages
        self.trimmer = trim_messages(
            max_tokens=25000,
            strategy="last",
            token_counter=model,
            include_system=True,
            allow_partial=False,
            start_on="human",
        )
        self.translator = Translator(self.model)
        print('Chatbot Initialized')

    def add_message(self, content, is_human=True):
        """
        Adds a message to the conversation history, either from Human or AI.
        Args:
        - content: Message content.
        - is_human: Boolean to determine if it is a human (True) or AI (False) message.
        """
        if is_human:
            self.messages.append(HumanMessage(content=content))
        else:
            self.messages.append(AIMessage(content=content))

    # Function to read the prompt from a text file
    def read_prompt_from_file(self,file_path):
        with open(file_path, 'r') as file:
            prompt_content = file.read()
        return prompt_content

    def get_prompt(self,file_path):
        # Read the system message from the file
        system_message = self.read_prompt_from_file(file_path)

        # Define the prompt with the system message from the file
        prompt = ChatPromptTemplate.from_messages(
            [
                (
                    "system",
                    system_message,
                ),
                MessagesPlaceholder(variable_name="messages"),
            ]
        )
        return prompt

    def chat(self, input_text, api):
        """
        Processes the interactions, sending the input to the model and returning the response in real-time.
        
        Args:
        - input_text: The feedback agent's message.
        Returns:
        - response_content: The complete content of the message generated by the model.
        """

        # Generate the chat prompt based on the feedback agent's input and context
        chat_prompt = self.get_prompt(
            file_path='prompts/chatbot_prompt.txt'
        )

        # Add feedback agent's input to the chat history as it was a human.
        self.add_message(input_text, is_human=True)

        # Create a chain of operations for generating the response
        chain = (
            # Pass the chat messages through a trimmer to handle context size
            RunnablePassthrough.assign(messages=itemgetter("messages") | self.trimmer)
            # Use the chat prompt and model to generate the response
            | chat_prompt
            | self.model
        )

        response_content = ""

        answer = self.translator.answer(input_text,api)
        self.add_message(answer, is_human=False)




        # # Stream the model's response in real-time and accumulate it
        # for response in chain.stream(
        #     {
        #         "messages": self.messages
        #     },
        #     config=self.config
        # ):
        #     # Print each part of the response as it is generated
        #     print(response.content, end="", flush=True)
        #     # Accumulate the response content
        #     response_content += response.content

        # # Add AI response to chat history
        # self.add_message(response_content, is_human=False)

        print()
        return answer

    def save_conversation(self):
        """
        Saves the complete conversation to a text file with the date and time in the filename.
        """
        # Get the current timestamp to include in the file name
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        # Define the file path with timestamp and session ID
        file_path = f"conversations/conversation_{timestamp}_{self.session_id}_.txt"

        try:
            # Open the file in write mode and save each message
            with open(file_path, 'w') as f:
                for msg in self.messages:
                    # Determine the sender: either "Human" or "AI"
                    sender = "Human" if isinstance(msg, HumanMessage) else "AI"
                    # Write each message to the file
                    f.write(f"{sender}: {msg.content}\n")
            print(f"Conversation successfully saved to {file_path}.")
        except Exception as e:
            print(f"Error saving the conversation: {e}")